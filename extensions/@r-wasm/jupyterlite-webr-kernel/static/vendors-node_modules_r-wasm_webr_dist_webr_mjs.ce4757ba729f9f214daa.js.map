{"version":3,"file":"vendors-node_modules_r-wasm_webr_dist_webr_mjs.ce4757ba729f9f214daa.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAA8B,GAAG,sEAAO,GAAG,CAE7E;AACN,MAAM,IAA8B;AACpC,WAAW,sEAAO;AAClB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,6BAA6B,4FAA4F;AACzH;AACA;AACA;AACA,mGAAmG;AACnG,yEAAyE,8BAA8B;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO,oBAAoB,OAAO,YAAY,OAAO,mCAAmC,OAAO;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,+CAA+C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,aAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,MAAM;AACN,mCAAmC,gBAAgB;AACnD;AACA;AACA,OAAO,mDAAmD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAAqE;AACtF;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4FAA4F,cAAc;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,MAAM;AACN,mCAAmC,cAAc;AACjD;AACA;AACA,OAAO,mDAAmD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8BAA8B;AAC1E,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW,yBAAyB,KAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAA8C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY,IAAI;AAC7B;AACA;AACA;AACA,8DAA8D,OAAO;AACrE,OAAO;AACP;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,IAAI;AACJ,aAAa;AACb,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,YAAY;AAC7G;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA,OAAO;AACP;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA,OAAO;AACP;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA,OAAO;AACP;AACA,sBAAsB,uBAAuB;AAC7C;AACA,OAAO;AACP;AACA,sBAAsB,2BAA2B;AACjD;AACA,OAAO;AACP;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AAKE;AACF;;;;;;;;;;;ACz0EA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B","sources":["webpack://@r-wasm/jupyterlite-webr-kernel/./node_modules/@r-wasm/webr/dist/webr.mjs","webpack://@r-wasm/jupyterlite-webr-kernel/./node_modules/process/browser.js"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// webR/compat.ts\nvar IN_NODE = typeof process !== \"undefined\" && process.release && process.release.name === \"node\" && typeof process.browser === \"undefined\";\nvar loadScript;\nif (globalThis.document) {\n  loadScript = (url) => new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = url;\n    script.onload = () => resolve();\n    script.onerror = reject;\n    document.head.appendChild(script);\n  });\n} else if (globalThis.importScripts) {\n  loadScript = async (url) => {\n    try {\n      globalThis.importScripts(url);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        await Promise.resolve().then(() => __toESM(__require(url)));\n      } else {\n        throw e;\n      }\n    }\n  };\n} else if (IN_NODE) {\n  loadScript = async (url) => {\n    const nodePathMod = (await Promise.resolve().then(() => __toESM(__require(\"path\")))).default;\n    await Promise.resolve().then(() => __toESM(__require(nodePathMod.resolve(url))));\n  };\n} else {\n  throw new Error(\"Cannot determine runtime environment\");\n}\n\n// webR/utils.ts\nfunction promiseHandles() {\n  const out = {\n    resolve: (_value) => {\n    },\n    reject: (_reason) => {\n    },\n    promise: null\n  };\n  const promise = new Promise((resolve, reject) => {\n    out.resolve = resolve;\n    out.reject = reject;\n  });\n  out.promise = promise;\n  return out;\n}\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction replaceInObject(obj, test, replacer, ...replacerArgs) {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (test(obj)) {\n    return replacer(obj, ...replacerArgs);\n  }\n  if (Array.isArray(obj) || ArrayBuffer.isView(obj)) {\n    return obj.map(\n      (v) => replaceInObject(v, test, replacer, ...replacerArgs)\n    );\n  }\n  return Object.fromEntries(\n    Object.entries(obj).map(([k, v], i) => [k, replaceInObject(v, test, replacer, ...replacerArgs)])\n  );\n}\nfunction newCrossOriginWorker(url, cb) {\n  const req = new XMLHttpRequest();\n  req.open(\"get\", url, true);\n  req.onload = () => {\n    const worker = new Worker(URL.createObjectURL(new Blob([req.responseText])));\n    cb(worker);\n  };\n  req.send();\n}\nfunction isCrossOrigin(urlString) {\n  if (IN_NODE)\n    return false;\n  const url1 = new URL(location.href);\n  const url2 = new URL(urlString, location.origin);\n  if (url1.host === url2.host && url1.port === url2.port && url1.protocol === url2.protocol) {\n    return false;\n  }\n  return true;\n}\n\n// webR/chan/task-common.ts\nvar SZ_BUF_DOESNT_FIT = 0;\nvar SZ_BUF_FITS_IDX = 1;\nvar SZ_BUF_SIZE_IDX = 0;\nvar transferCache = /* @__PURE__ */ new WeakMap();\nfunction transfer(obj, transfers) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\nvar UUID_LENGTH = 63;\nfunction generateUUID() {\n  const result = Array.from({ length: 4 }, randomSegment).join(\"-\");\n  if (result.length !== UUID_LENGTH) {\n    throw new Error(\"comlink internal error: UUID has the wrong length\");\n  }\n  return result;\n}\nfunction randomSegment() {\n  let result = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n  const pad = 15 - result.length;\n  if (pad > 0) {\n    result = Array.from({ length: pad }, () => 0).join(\"\") + result;\n  }\n  return result;\n}\n\n// webR/chan/message.ts\nfunction newRequest(msg, transferables) {\n  return newRequestResponseMessage(\n    {\n      type: \"request\",\n      data: {\n        uuid: generateUUID(),\n        msg\n      }\n    },\n    transferables\n  );\n}\nfunction newResponse(uuid, resp, transferables) {\n  return newRequestResponseMessage(\n    {\n      type: \"response\",\n      data: {\n        uuid,\n        resp\n      }\n    },\n    transferables\n  );\n}\nfunction newRequestResponseMessage(msg, transferables) {\n  if (transferables) {\n    transfer(msg, transferables);\n  }\n  return msg;\n}\nfunction newSyncRequest(msg, data) {\n  return {\n    type: \"sync-request\",\n    data: { msg, reqData: data }\n  };\n}\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder(\"utf-8\");\nfunction encodeData(data) {\n  return encoder.encode(JSON.stringify(data));\n}\nfunction decodeData(data) {\n  return JSON.parse(decoder.decode(data));\n}\n\n// webR/chan/task-main.ts\nvar encoder2 = new TextEncoder();\nasync function syncResponse(endpoint, data, response) {\n  try {\n    let { taskId, sizeBuffer, dataBuffer, signalBuffer } = data;\n    const bytes = encodeData(response);\n    const fits = bytes.length <= dataBuffer.length;\n    Atomics.store(sizeBuffer, SZ_BUF_SIZE_IDX, bytes.length);\n    Atomics.store(sizeBuffer, SZ_BUF_FITS_IDX, +fits);\n    if (!fits) {\n      const [uuid, dataPromise] = requestResponseMessage(endpoint);\n      dataBuffer.set(encoder2.encode(uuid));\n      await signalRequester(signalBuffer, taskId);\n      dataBuffer = (await dataPromise).dataBuffer;\n    }\n    dataBuffer.set(bytes);\n    Atomics.store(sizeBuffer, SZ_BUF_FITS_IDX, 1);\n    await signalRequester(signalBuffer, taskId);\n  } catch (e) {\n    console.warn(e);\n  }\n}\nfunction requestResponseMessage(ep) {\n  const id = generateUUID();\n  return [\n    id,\n    new Promise((resolve) => {\n      if (IN_NODE) {\n        ep.once(\"message\", (message) => {\n          if (!message.id || message.id !== id) {\n            return;\n          }\n          resolve(message);\n        });\n      } else {\n        ep.addEventListener(\"message\", function l(ev) {\n          if (!ev.data || !ev.data.id || ev.data.id !== id) {\n            return;\n          }\n          ep.removeEventListener(\"message\", l);\n          resolve(ev.data);\n        });\n      }\n      if (ep.start) {\n        ep.start();\n      }\n    })\n  ];\n}\nasync function signalRequester(signalBuffer, taskId) {\n  const index = (taskId >> 1) % 32;\n  let sleepTime = 1;\n  while (Atomics.compareExchange(signalBuffer, index + 1, 0, taskId) !== 0) {\n    await sleep(sleepTime);\n    if (sleepTime < 32) {\n      sleepTime *= 2;\n    }\n  }\n  Atomics.or(signalBuffer, 0, 1 << index);\n  Atomics.notify(signalBuffer, 0);\n}\n\n// webR/chan/queue.ts\nvar _promises, _resolvers, _add, add_fn;\nvar AsyncQueue = class {\n  constructor() {\n    __privateAdd(this, _add);\n    __privateAdd(this, _promises, void 0);\n    __privateAdd(this, _resolvers, void 0);\n    __privateSet(this, _resolvers, []);\n    __privateSet(this, _promises, []);\n  }\n  put(t) {\n    if (!__privateGet(this, _resolvers).length) {\n      __privateMethod(this, _add, add_fn).call(this);\n    }\n    const resolve = __privateGet(this, _resolvers).shift();\n    resolve(t);\n  }\n  async get() {\n    if (!__privateGet(this, _promises).length) {\n      __privateMethod(this, _add, add_fn).call(this);\n    }\n    const promise = __privateGet(this, _promises).shift();\n    return promise;\n  }\n  isEmpty() {\n    return !__privateGet(this, _promises).length;\n  }\n  isBlocked() {\n    return !!__privateGet(this, _resolvers).length;\n  }\n  get length() {\n    return __privateGet(this, _promises).length - __privateGet(this, _resolvers).length;\n  }\n};\n_promises = new WeakMap();\n_resolvers = new WeakMap();\n_add = new WeakSet();\nadd_fn = function() {\n  __privateGet(this, _promises).push(\n    new Promise((resolve) => {\n      __privateGet(this, _resolvers).push(resolve);\n    })\n  );\n};\n\n// webR/payload.ts\nfunction webRPayloadError(payload) {\n  const e = new Error(payload.obj.message);\n  e.name = payload.obj.name;\n  e.stack = payload.obj.stack;\n  return e;\n}\nfunction isWebRPayload(value) {\n  return value && typeof value === \"object\" && \"payloadType\" in value && \"obj\" in value;\n}\nfunction isWebRPayloadPtr(value) {\n  return isWebRPayload(value) && value.payloadType === \"ptr\";\n}\n\n// webR/chan/channel.ts\nvar _parked;\nvar ChannelMain = class {\n  constructor() {\n    this.inputQueue = new AsyncQueue();\n    this.outputQueue = new AsyncQueue();\n    __privateAdd(this, _parked, /* @__PURE__ */ new Map());\n  }\n  async read() {\n    return await this.outputQueue.get();\n  }\n  async flush() {\n    const msg = [];\n    while (!this.outputQueue.isEmpty()) {\n      msg.push(await this.read());\n    }\n    return msg;\n  }\n  write(msg) {\n    this.inputQueue.put(msg);\n  }\n  async request(msg, transferables) {\n    const req = newRequest(msg, transferables);\n    const { resolve, reject, promise } = promiseHandles();\n    __privateGet(this, _parked).set(req.data.uuid, { resolve, reject });\n    this.write(req);\n    return promise;\n  }\n  resolveResponse(msg) {\n    const uuid = msg.data.uuid;\n    const handles = __privateGet(this, _parked).get(uuid);\n    if (handles) {\n      const payload = msg.data.resp;\n      __privateGet(this, _parked).delete(uuid);\n      if (payload.payloadType === \"err\") {\n        handles.reject(webRPayloadError(payload));\n      } else {\n        handles.resolve(payload);\n      }\n    } else {\n      console.warn(\"Can't find request.\");\n    }\n  }\n};\n_parked = new WeakMap();\n\n// webR/chan/task-worker.ts\nvar decoder2 = new TextDecoder(\"utf-8\");\nvar _scheduled, _resolved, _result, _exception, _syncGen;\nvar SyncTask = class {\n  constructor(endpoint, msg, transfers = []) {\n    __privateAdd(this, _scheduled, false);\n    __privateAdd(this, _resolved, void 0);\n    __privateAdd(this, _result, void 0);\n    __privateAdd(this, _exception, void 0);\n    __privateAdd(this, _syncGen, void 0);\n    this.syncifier = new _Syncifier();\n    this.endpoint = endpoint;\n    this.msg = msg;\n    this.transfers = transfers;\n    __privateSet(this, _resolved, false);\n  }\n  scheduleSync() {\n    if (__privateGet(this, _scheduled)) {\n      return;\n    }\n    __privateSet(this, _scheduled, true);\n    this.syncifier.scheduleTask(this);\n    __privateSet(this, _syncGen, this.doSync());\n    __privateGet(this, _syncGen).next();\n    return this;\n  }\n  poll() {\n    if (!__privateGet(this, _scheduled)) {\n      throw new Error(\"Task not synchronously scheduled\");\n    }\n    const { done, value } = __privateGet(this, _syncGen).next();\n    if (!done) {\n      return false;\n    }\n    __privateSet(this, _resolved, true);\n    __privateSet(this, _result, value);\n    return true;\n  }\n  *doSync() {\n    const { endpoint, msg, transfers } = this;\n    const sizeBuffer = new Int32Array(new SharedArrayBuffer(8));\n    const signalBuffer = this.signalBuffer;\n    const taskId = this.taskId;\n    let dataBuffer = acquireDataBuffer(UUID_LENGTH);\n    const syncMsg = newSyncRequest(msg, {\n      sizeBuffer,\n      dataBuffer,\n      signalBuffer,\n      taskId\n    });\n    endpoint.postMessage(syncMsg, transfers);\n    yield;\n    if (Atomics.load(sizeBuffer, SZ_BUF_FITS_IDX) === SZ_BUF_DOESNT_FIT) {\n      const id = decoder2.decode(dataBuffer.slice(0, UUID_LENGTH));\n      releaseDataBuffer(dataBuffer);\n      const size2 = Atomics.load(sizeBuffer, SZ_BUF_SIZE_IDX);\n      dataBuffer = acquireDataBuffer(size2);\n      endpoint.postMessage({ id, dataBuffer });\n      yield;\n    }\n    const size = Atomics.load(sizeBuffer, SZ_BUF_SIZE_IDX);\n    return decodeData(dataBuffer.slice(0, size));\n  }\n  get result() {\n    if (__privateGet(this, _exception)) {\n      throw __privateGet(this, _exception);\n    }\n    if (__privateGet(this, _resolved)) {\n      return __privateGet(this, _result);\n    }\n    throw new Error(\"Not ready.\");\n  }\n  syncify() {\n    this.scheduleSync();\n    this.syncifier.syncifyTask(this);\n    return this.result;\n  }\n};\n_scheduled = new WeakMap();\n_resolved = new WeakMap();\n_result = new WeakMap();\n_exception = new WeakMap();\n_syncGen = new WeakMap();\nvar _Syncifier = class {\n  constructor() {\n    this.nextTaskId = new Int32Array([1]);\n    this.signalBuffer = new Int32Array(new SharedArrayBuffer(32 * 4 + 4));\n    this.tasks = /* @__PURE__ */ new Map();\n  }\n  scheduleTask(task) {\n    task.taskId = this.nextTaskId[0];\n    this.nextTaskId[0] += 2;\n    task.signalBuffer = this.signalBuffer;\n    this.tasks.set(task.taskId, task);\n  }\n  waitOnSignalBuffer() {\n    const timeout = 50;\n    for (; ; ) {\n      const status = Atomics.wait(this.signalBuffer, 0, 0, timeout);\n      switch (status) {\n        case \"ok\":\n        case \"not-equal\":\n          return;\n        case \"timed-out\":\n          if (interruptBuffer[0] !== 0) {\n            handleInterrupt();\n          }\n          break;\n        default:\n          throw new Error(\"Unreachable\");\n      }\n    }\n  }\n  *tasksIdsToWakeup() {\n    const flag = Atomics.load(this.signalBuffer, 0);\n    for (let i = 0; i < 32; i++) {\n      const bit = 1 << i;\n      if (flag & bit) {\n        Atomics.and(this.signalBuffer, 0, ~bit);\n        const wokenTask = Atomics.exchange(this.signalBuffer, i + 1, 0);\n        yield wokenTask;\n      }\n    }\n  }\n  pollTasks(task) {\n    let result = false;\n    for (const wokenTaskId of this.tasksIdsToWakeup()) {\n      const wokenTask = this.tasks.get(wokenTaskId);\n      if (!wokenTask) {\n        throw new Error(`Assertion error: unknown taskId ${wokenTaskId}.`);\n      }\n      if (wokenTask.poll()) {\n        this.tasks.delete(wokenTaskId);\n        if (wokenTask === task) {\n          result = true;\n        }\n      }\n    }\n    return result;\n  }\n  syncifyTask(task) {\n    for (; ; ) {\n      this.waitOnSignalBuffer();\n      if (this.pollTasks(task)) {\n        return;\n      }\n    }\n  }\n};\nvar dataBuffers = [];\nfunction acquireDataBuffer(size) {\n  const powerof2 = Math.ceil(Math.log2(size));\n  if (!dataBuffers[powerof2]) {\n    dataBuffers[powerof2] = [];\n  }\n  const result = dataBuffers[powerof2].pop();\n  if (result) {\n    result.fill(0);\n    return result;\n  }\n  return new Uint8Array(new SharedArrayBuffer(2 ** powerof2));\n}\nfunction releaseDataBuffer(buffer) {\n  const powerof2 = Math.ceil(Math.log2(buffer.byteLength));\n  dataBuffers[powerof2].push(buffer);\n}\nvar interruptBuffer = new Int32Array(new ArrayBuffer(4));\nvar handleInterrupt = () => {\n  interruptBuffer[0] = 0;\n  throw new Error(\"Interrupted!\");\n};\nfunction setInterruptHandler(handler) {\n  handleInterrupt = handler;\n}\nfunction setInterruptBuffer(buffer) {\n  interruptBuffer = new Int32Array(buffer);\n}\n\n// webR/emscripten.ts\nvar Module = {};\nfunction dictEmFree(dict) {\n  Object.keys(dict).forEach((key) => Module._free(dict[key]));\n}\n\n// webR/chan/channel-shared.ts\nif (IN_NODE) {\n  globalThis.Worker = __require(\"worker_threads\").Worker;\n}\nvar _interruptBuffer, _handleEventsFromWorker, handleEventsFromWorker_fn, _onMessageFromWorker;\nvar SharedBufferChannelMain = class extends ChannelMain {\n  constructor(config) {\n    super();\n    __privateAdd(this, _handleEventsFromWorker);\n    __privateAdd(this, _interruptBuffer, void 0);\n    this.close = () => {\n    };\n    __privateAdd(this, _onMessageFromWorker, async (worker, message) => {\n      if (!message || !message.type) {\n        return;\n      }\n      switch (message.type) {\n        case \"resolve\":\n          __privateSet(this, _interruptBuffer, new Int32Array(message.data));\n          this.resolve();\n          return;\n        case \"response\":\n          this.resolveResponse(message);\n          return;\n        default:\n          this.outputQueue.put(message);\n          return;\n        case \"sync-request\": {\n          const msg = message;\n          const payload = msg.data.msg;\n          const reqData = msg.data.reqData;\n          switch (payload.type) {\n            case \"read\": {\n              const response = await this.inputQueue.get();\n              await syncResponse(worker, reqData, response);\n              break;\n            }\n            default:\n              throw new TypeError(`Unsupported request type '${payload.type}'.`);\n          }\n          return;\n        }\n        case \"request\":\n          throw new TypeError(\n            \"Can't send messages of type 'request' from a worker. Please Use 'sync-request' instead.\"\n          );\n      }\n    });\n    const initWorker = (worker) => {\n      __privateMethod(this, _handleEventsFromWorker, handleEventsFromWorker_fn).call(this, worker);\n      this.close = () => worker.terminate();\n      const msg = {\n        type: \"init\",\n        data: { config, channelType: ChannelType.SharedArrayBuffer }\n      };\n      worker.postMessage(msg);\n    };\n    if (isCrossOrigin(config.WEBR_URL)) {\n      newCrossOriginWorker(\n        `${config.WEBR_URL}webr-worker.js`,\n        (worker) => initWorker(worker)\n      );\n    } else {\n      const worker = new Worker(`${config.WEBR_URL}webr-worker.js`);\n      initWorker(worker);\n    }\n    ({ resolve: this.resolve, promise: this.initialised } = promiseHandles());\n  }\n  interrupt() {\n    if (!__privateGet(this, _interruptBuffer)) {\n      throw new Error(\"Failed attempt to interrupt before initialising interruptBuffer\");\n    }\n    __privateGet(this, _interruptBuffer)[0] = 1;\n  }\n};\n_interruptBuffer = new WeakMap();\n_handleEventsFromWorker = new WeakSet();\nhandleEventsFromWorker_fn = function(worker) {\n  if (IN_NODE) {\n    worker.on(\"message\", (message) => {\n      __privateGet(this, _onMessageFromWorker).call(this, worker, message);\n    });\n  } else {\n    worker.onmessage = (ev) => __privateGet(this, _onMessageFromWorker).call(this, worker, ev.data);\n  }\n};\n_onMessageFromWorker = new WeakMap();\nvar _ep, _dispatch, _interruptBuffer2, _interrupt;\nvar SharedBufferChannelWorker = class {\n  constructor() {\n    __privateAdd(this, _ep, void 0);\n    __privateAdd(this, _dispatch, () => 0);\n    __privateAdd(this, _interruptBuffer2, new Int32Array(new SharedArrayBuffer(4)));\n    __privateAdd(this, _interrupt, () => {\n    });\n    __privateSet(this, _ep, IN_NODE ? __require(\"worker_threads\").parentPort : globalThis);\n    setInterruptBuffer(__privateGet(this, _interruptBuffer2).buffer);\n    setInterruptHandler(() => this.handleInterrupt());\n  }\n  resolve() {\n    this.write({ type: \"resolve\", data: __privateGet(this, _interruptBuffer2).buffer });\n  }\n  write(msg, transfer2) {\n    __privateGet(this, _ep).postMessage(msg, transfer2);\n  }\n  read() {\n    const msg = { type: \"read\" };\n    const task = new SyncTask(__privateGet(this, _ep), msg);\n    return task.syncify();\n  }\n  inputOrDispatch() {\n    for (; ; ) {\n      const msg = this.read();\n      if (msg.type === \"stdin\") {\n        return Module.allocateUTF8(msg.data);\n      }\n      __privateGet(this, _dispatch).call(this, msg);\n    }\n  }\n  run(args) {\n    Module.callMain(args);\n  }\n  setInterrupt(interrupt) {\n    __privateSet(this, _interrupt, interrupt);\n  }\n  handleInterrupt() {\n    if (__privateGet(this, _interruptBuffer2)[0] !== 0) {\n      __privateGet(this, _interruptBuffer2)[0] = 0;\n      __privateGet(this, _interrupt).call(this);\n    }\n  }\n  setDispatchHandler(dispatch) {\n    __privateSet(this, _dispatch, dispatch);\n  }\n};\n_ep = new WeakMap();\n_dispatch = new WeakMap();\n_interruptBuffer2 = new WeakMap();\n_interrupt = new WeakMap();\n\n// webR/chan/channel-service.ts\nif (IN_NODE) {\n  globalThis.Worker = __require(\"worker_threads\").Worker;\n}\nvar _syncMessageCache, _registration, _interrupted, _registerServiceWorker, registerServiceWorker_fn, _onMessageFromServiceWorker, onMessageFromServiceWorker_fn, _handleEventsFromWorker2, handleEventsFromWorker_fn2, _onMessageFromWorker2;\nvar ServiceWorkerChannelMain = class extends ChannelMain {\n  constructor(config) {\n    super();\n    __privateAdd(this, _registerServiceWorker);\n    __privateAdd(this, _onMessageFromServiceWorker);\n    __privateAdd(this, _handleEventsFromWorker2);\n    this.close = () => {\n    };\n    __privateAdd(this, _syncMessageCache, /* @__PURE__ */ new Map());\n    __privateAdd(this, _registration, void 0);\n    __privateAdd(this, _interrupted, false);\n    __privateAdd(this, _onMessageFromWorker2, async (worker, message) => {\n      if (!message || !message.type) {\n        return;\n      }\n      switch (message.type) {\n        case \"resolve\":\n          this.resolve();\n          return;\n        case \"response\":\n          this.resolveResponse(message);\n          return;\n        default:\n          this.outputQueue.put(message);\n          return;\n        case \"sync-request\": {\n          const request = message.data;\n          __privateGet(this, _syncMessageCache).set(request.data.uuid, request.data.msg);\n          return;\n        }\n        case \"request\":\n          throw new TypeError(\n            \"Can't send messages of type 'request' from a worker.Use service worker fetch request instead.\"\n          );\n      }\n    });\n    const initWorker = (worker) => {\n      __privateMethod(this, _handleEventsFromWorker2, handleEventsFromWorker_fn2).call(this, worker);\n      this.close = () => worker.terminate();\n      __privateMethod(this, _registerServiceWorker, registerServiceWorker_fn).call(this, `${config.SW_URL}webr-serviceworker.js`).then((clientId) => {\n        const msg = {\n          type: \"init\",\n          data: {\n            config,\n            channelType: ChannelType.ServiceWorker,\n            clientId,\n            location: window.location.href\n          }\n        };\n        worker.postMessage(msg);\n      });\n    };\n    if (isCrossOrigin(config.SW_URL)) {\n      newCrossOriginWorker(\n        `${config.SW_URL}webr-worker.js`,\n        (worker) => initWorker(worker)\n      );\n    } else {\n      const worker = new Worker(`${config.SW_URL}webr-worker.js`);\n      initWorker(worker);\n    }\n    ({ resolve: this.resolve, promise: this.initialised } = promiseHandles());\n  }\n  activeRegistration() {\n    var _a;\n    if (!((_a = __privateGet(this, _registration)) == null ? void 0 : _a.active)) {\n      throw new Error(\"Attempted to obtain a non-existent active registration.\");\n    }\n    return __privateGet(this, _registration).active;\n  }\n  interrupt() {\n    __privateSet(this, _interrupted, true);\n  }\n};\n_syncMessageCache = new WeakMap();\n_registration = new WeakMap();\n_interrupted = new WeakMap();\n_registerServiceWorker = new WeakSet();\nregisterServiceWorker_fn = async function(url) {\n  __privateSet(this, _registration, await navigator.serviceWorker.register(url));\n  await navigator.serviceWorker.ready;\n  window.addEventListener(\"beforeunload\", () => {\n    var _a;\n    (_a = __privateGet(this, _registration)) == null ? void 0 : _a.unregister();\n  });\n  const clientId = await new Promise((resolve) => {\n    navigator.serviceWorker.addEventListener(\n      \"message\",\n      function listener(event) {\n        if (event.data.type === \"registration-successful\") {\n          navigator.serviceWorker.removeEventListener(\"message\", listener);\n          resolve(event.data.clientId);\n        }\n      }\n    );\n    this.activeRegistration().postMessage({ type: \"register-client-main\" });\n  });\n  navigator.serviceWorker.addEventListener(\"message\", (event) => {\n    __privateMethod(this, _onMessageFromServiceWorker, onMessageFromServiceWorker_fn).call(this, event);\n  });\n  return clientId;\n};\n_onMessageFromServiceWorker = new WeakSet();\nonMessageFromServiceWorker_fn = async function(event) {\n  if (event.data.type === \"request\") {\n    const uuid = event.data.data;\n    const message = __privateGet(this, _syncMessageCache).get(uuid);\n    if (!message) {\n      throw new Error(\"Request not found during service worker XHR request\");\n    }\n    __privateGet(this, _syncMessageCache).delete(uuid);\n    switch (message.type) {\n      case \"read\": {\n        const response = await this.inputQueue.get();\n        this.activeRegistration().postMessage({\n          type: \"wasm-webr-fetch-response\",\n          uuid,\n          response: newResponse(uuid, response)\n        });\n        break;\n      }\n      case \"interrupt\": {\n        const response = __privateGet(this, _interrupted);\n        this.activeRegistration().postMessage({\n          type: \"wasm-webr-fetch-response\",\n          uuid,\n          response: newResponse(uuid, response)\n        });\n        __privateSet(this, _interrupted, false);\n        break;\n      }\n      default:\n        throw new TypeError(`Unsupported request type '${message.type}'.`);\n    }\n    return;\n  }\n};\n_handleEventsFromWorker2 = new WeakSet();\nhandleEventsFromWorker_fn2 = function(worker) {\n  if (IN_NODE) {\n    worker.on(\"message\", (message) => {\n      __privateGet(this, _onMessageFromWorker2).call(this, worker, message);\n    });\n  } else {\n    worker.onmessage = (ev) => __privateGet(this, _onMessageFromWorker2).call(this, worker, ev.data);\n  }\n};\n_onMessageFromWorker2 = new WeakMap();\nvar _ep2, _mainThreadId, _location, _dispatch2, _interrupt2;\nvar ServiceWorkerChannelWorker = class {\n  constructor(data) {\n    __privateAdd(this, _ep2, void 0);\n    __privateAdd(this, _mainThreadId, void 0);\n    __privateAdd(this, _location, void 0);\n    __privateAdd(this, _dispatch2, () => 0);\n    __privateAdd(this, _interrupt2, () => {\n    });\n    this.onMessageFromMainThread = () => {\n    };\n    if (!data.clientId || !data.location) {\n      throw Error(\"Can't start service worker channel\");\n    }\n    __privateSet(this, _mainThreadId, data.clientId);\n    __privateSet(this, _location, data.location);\n    __privateSet(this, _ep2, IN_NODE ? __require(\"worker_threads\").parentPort : globalThis);\n  }\n  resolve() {\n    this.write({ type: \"resolve\" });\n  }\n  write(msg, transfer2) {\n    __privateGet(this, _ep2).postMessage(msg, transfer2);\n  }\n  syncRequest(message) {\n    const request = newRequest(message);\n    this.write({ type: \"sync-request\", data: request });\n    let retryCount = 0;\n    for (; ; ) {\n      try {\n        const url = new URL(\"__wasm__/webr-fetch-request/\", __privateGet(this, _location));\n        const xhr = new XMLHttpRequest();\n        xhr.timeout = 6e4;\n        xhr.responseType = \"arraybuffer\";\n        xhr.open(\"POST\", url, false);\n        const fetchReqBody = {\n          clientId: __privateGet(this, _mainThreadId),\n          uuid: request.data.uuid\n        };\n        xhr.send(encodeData(fetchReqBody));\n        return decodeData(new Uint8Array(xhr.response));\n      } catch (e) {\n        if (e instanceof DOMException && retryCount++ < 1e3) {\n          console.log(\"Service worker request failed - resending request\");\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n  read() {\n    const response = this.syncRequest({ type: \"read\" });\n    return response.data.resp;\n  }\n  inputOrDispatch() {\n    for (; ; ) {\n      const msg = this.read();\n      if (msg.type === \"stdin\") {\n        return Module.allocateUTF8(msg.data);\n      }\n      __privateGet(this, _dispatch2).call(this, msg);\n    }\n  }\n  run(args) {\n    Module.callMain(args);\n  }\n  setInterrupt(interrupt) {\n    __privateSet(this, _interrupt2, interrupt);\n  }\n  handleInterrupt() {\n    const response = this.syncRequest({ type: \"interrupt\" });\n    const interrupted = response.data.resp;\n    if (interrupted) {\n      __privateGet(this, _interrupt2).call(this);\n    }\n  }\n  setDispatchHandler(dispatch) {\n    __privateSet(this, _dispatch2, dispatch);\n  }\n};\n_ep2 = new WeakMap();\n_mainThreadId = new WeakMap();\n_location = new WeakMap();\n_dispatch2 = new WeakMap();\n_interrupt2 = new WeakMap();\n\n// webR/chan/channel-common.ts\nvar ChannelType = {\n  Automatic: 0,\n  SharedArrayBuffer: 1,\n  ServiceWorker: 2\n};\nfunction newChannelMain(data) {\n  switch (data.channelType) {\n    case ChannelType.SharedArrayBuffer:\n      return new SharedBufferChannelMain(data);\n    case ChannelType.ServiceWorker:\n      return new ServiceWorkerChannelMain(data);\n    case ChannelType.Automatic:\n    default:\n      if (IN_NODE || crossOriginIsolated) {\n        return new SharedBufferChannelMain(data);\n      }\n      if (\"serviceWorker\" in navigator && !isCrossOrigin(data.SW_URL)) {\n        return new ServiceWorkerChannelMain(data);\n      }\n      throw new Error(\"Can't initialise main thread communication channel\");\n  }\n}\n\n// webR/config.ts\nvar BASE_URL = \"https://webr.r-wasm.org/v0.1.0/\";\nvar PKG_BASE_URL = \"https://repo.r-wasm.org\";\n\n// webR/robj-main.ts\nfunction isRObject(value) {\n  return value && (typeof value === \"object\" || typeof value === \"function\") && \"payloadType\" in value && isWebRPayloadPtr(value._payload);\n}\nfunction isRFunction(value) {\n  var _a;\n  return Boolean(isRObject(value) && ((_a = value._payload.obj.methods) == null ? void 0 : _a.includes(\"exec\")));\n}\n\n// webR/robj.ts\nvar RTypeMap = {\n  null: 0,\n  symbol: 1,\n  pairlist: 2,\n  closure: 3,\n  environment: 4,\n  promise: 5,\n  call: 6,\n  special: 7,\n  builtin: 8,\n  string: 9,\n  logical: 10,\n  integer: 13,\n  double: 14,\n  complex: 15,\n  character: 16,\n  dots: 17,\n  any: 18,\n  list: 19,\n  expression: 20,\n  bytecode: 21,\n  pointer: 22,\n  weakref: 23,\n  raw: 24,\n  s4: 25,\n  new: 30,\n  free: 31,\n  function: 99\n};\nfunction isWebRDataJs(value) {\n  return value && typeof value === \"object\" && Object.keys(RTypeMap).includes(value.type);\n}\nfunction isComplex(value) {\n  return value && typeof value === \"object\" && \"re\" in value && \"im\" in value;\n}\n\n// webR/utils-r.ts\nfunction protect(x) {\n  Module._Rf_protect(handlePtr(x));\n  return x;\n}\nfunction protectInc(x, prot) {\n  Module._Rf_protect(handlePtr(x));\n  ++prot.n;\n  return x;\n}\nfunction protectWithIndex(x) {\n  const pLoc = Module._malloc(4);\n  Module._R_ProtectWithIndex(handlePtr(x), pLoc);\n  const loc = Module.getValue(pLoc, \"i32\");\n  return { loc, ptr: pLoc };\n}\nfunction unprotectIndex(index) {\n  Module._Rf_unprotect(1);\n  Module._free(index.ptr);\n}\nfunction reprotect(x, index) {\n  Module._R_Reprotect(handlePtr(x), index.loc);\n  return x;\n}\nfunction unprotect(n) {\n  Module._Rf_unprotect(n);\n}\nfunction envPoke(env, sym, value) {\n  Module._Rf_defineVar(handlePtr(sym), handlePtr(value), handlePtr(env));\n}\nfunction parseEvalBare(code, env) {\n  const strings = {};\n  const prot = { n: 0 };\n  try {\n    const envObj = new REnvironment(env);\n    protectInc(envObj, prot);\n    strings.code = Module.allocateUTF8(code);\n    const out = Module._R_ParseEvalString(strings.code, envObj.ptr);\n    return RObject.wrap(out);\n  } finally {\n    dictEmFree(strings);\n    unprotect(prot.n);\n  }\n}\nfunction safeEval(call, env) {\n  return Module.LDSO.loadedLibsByName[\"/usr/lib/R/library/webr/libs/webr.so\"].module.ffi_safe_eval(\n    handlePtr(call),\n    handlePtr(env)\n  );\n}\n\n// webR/robj-worker.ts\nfunction handlePtr(x) {\n  if (isRObject2(x)) {\n    return x.ptr;\n  } else {\n    return x;\n  }\n}\nfunction assertRType(obj, type) {\n  if (Module._TYPEOF(obj.ptr) !== RTypeMap[type]) {\n    throw new Error(`Unexpected object type \"${obj.type()}\" when expecting type \"${type}\"`);\n  }\n}\nfunction newObjectFromData(obj) {\n  if (isWebRDataJs(obj)) {\n    return new (getRWorkerClass(RTypeMap[obj.type]))(obj);\n  }\n  if (obj && typeof obj === \"object\" && \"type\" in obj && obj.type === \"null\") {\n    return new RNull();\n  }\n  if (obj === null) {\n    return new RLogical({ type: \"logical\", names: null, values: [null] });\n  }\n  if (typeof obj === \"boolean\") {\n    return new RLogical(obj);\n  }\n  if (typeof obj === \"number\") {\n    return new RDouble(obj);\n  }\n  if (typeof obj === \"string\") {\n    return new RCharacter(obj);\n  }\n  if (isComplex(obj)) {\n    return new RComplex(obj);\n  }\n  if (Array.isArray(obj)) {\n    return newObjectFromArray(obj);\n  }\n  throw new Error(\"Robj construction for this JS object is not yet supported\");\n}\nfunction newObjectFromArray(arr) {\n  const prot = { n: 0 };\n  try {\n    const call = new RCall([new RSymbol(\"c\"), ...arr]);\n    protectInc(call, prot);\n    return call.eval();\n  } finally {\n    unprotect(prot.n);\n  }\n}\nvar RObjectBase = class {\n  constructor(ptr) {\n    this.ptr = ptr;\n  }\n  type() {\n    const typeNumber = Module._TYPEOF(this.ptr);\n    const type = Object.keys(RTypeMap).find(\n      (typeName) => RTypeMap[typeName] === typeNumber\n    );\n    return type;\n  }\n};\nvar _slice, slice_fn;\nvar _RObject = class extends RObjectBase {\n  constructor(data) {\n    if (!(data instanceof RObjectBase)) {\n      return newObjectFromData(data);\n    }\n    super(data.ptr);\n    __privateAdd(this, _slice);\n  }\n  static wrap(ptr) {\n    const type = Module._TYPEOF(ptr);\n    return new (getRWorkerClass(type))(new RObjectBase(ptr));\n  }\n  get [Symbol.toStringTag]() {\n    return `RObject:${this.type()}`;\n  }\n  static getPersistentObject(prop) {\n    return objs[prop];\n  }\n  getPropertyValue(prop) {\n    return this[prop];\n  }\n  inspect() {\n    parseEvalBare(\".Internal(inspect(x))\", { x: this });\n  }\n  isNull() {\n    return Module._TYPEOF(this.ptr) === RTypeMap.null;\n  }\n  isUnbound() {\n    return this.ptr === objs.unboundValue.ptr;\n  }\n  attrs() {\n    return RPairlist.wrap(Module._ATTRIB(this.ptr));\n  }\n  setNames(values) {\n    let namesObj;\n    if (values === null) {\n      namesObj = objs.null;\n    } else if (Array.isArray(values) && values.every((v) => typeof v === \"string\" || v === null)) {\n      namesObj = new RCharacter(values);\n    } else {\n      throw new Error(\"Argument to setNames must be null or an Array of strings or null\");\n    }\n    Module._Rf_setAttrib(this.ptr, objs.namesSymbol.ptr, namesObj.ptr);\n    return this;\n  }\n  names() {\n    const names = RCharacter.wrap(Module._Rf_getAttrib(this.ptr, objs.namesSymbol.ptr));\n    if (names.isNull()) {\n      return null;\n    } else {\n      return names.toArray();\n    }\n  }\n  includes(name) {\n    const names = this.names();\n    return names && names.includes(name);\n  }\n  toJs(options = { depth: 0 }, depth = 1) {\n    throw new Error(\"This R object cannot be converted to JS\");\n  }\n  subset(prop) {\n    return __privateMethod(this, _slice, slice_fn).call(this, prop, objs.bracketSymbol.ptr);\n  }\n  get(prop) {\n    return __privateMethod(this, _slice, slice_fn).call(this, prop, objs.bracket2Symbol.ptr);\n  }\n  getDollar(prop) {\n    return __privateMethod(this, _slice, slice_fn).call(this, prop, objs.dollarSymbol.ptr);\n  }\n  pluck(...path) {\n    const index = protectWithIndex(objs.null);\n    try {\n      const getter = (obj, prop) => {\n        const out = obj.get(prop);\n        return reprotect(out, index);\n      };\n      const result = path.reduce(getter, this);\n      return result.isNull() ? void 0 : result;\n    } finally {\n      unprotectIndex(index);\n    }\n  }\n  set(prop, value) {\n    const prot = { n: 0 };\n    try {\n      const idx = new _RObject(prop);\n      protectInc(idx, prot);\n      const valueObj = new _RObject(value);\n      protectInc(valueObj, prot);\n      const assign = new RSymbol(\"[[<-\");\n      const call = Module._Rf_lang4(assign.ptr, this.ptr, idx.ptr, valueObj.ptr);\n      protectInc(call, prot);\n      return _RObject.wrap(safeEval(call, objs.baseEnv));\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n  static getMethods(obj) {\n    const props = /* @__PURE__ */ new Set();\n    let cur = obj;\n    do {\n      Object.getOwnPropertyNames(cur).map((p) => props.add(p));\n    } while (cur = Object.getPrototypeOf(cur));\n    return [...props.keys()].filter((i) => typeof obj[i] === \"function\");\n  }\n};\nvar RObject = _RObject;\n_slice = new WeakSet();\nslice_fn = function(prop, op) {\n  const prot = { n: 0 };\n  try {\n    const idx = new _RObject(prop);\n    protectInc(idx, prot);\n    const call = Module._Rf_lang3(op, this.ptr, idx.ptr);\n    protectInc(call, prot);\n    return _RObject.wrap(safeEval(call, objs.baseEnv));\n  } finally {\n    unprotect(prot.n);\n  }\n};\nvar RNull = class extends RObject {\n  constructor() {\n    super(new RObjectBase(Module.getValue(Module._R_NilValue, \"*\")));\n    return this;\n  }\n  toJs() {\n    return { type: \"null\" };\n  }\n};\nvar RSymbol = class extends RObject {\n  constructor(x) {\n    if (x instanceof RObjectBase) {\n      assertRType(x, \"symbol\");\n      super(x);\n      return;\n    }\n    const name = Module.allocateUTF8(x);\n    try {\n      super(new RObjectBase(Module._Rf_install(name)));\n    } finally {\n      Module._free(name);\n    }\n  }\n  toJs() {\n    const obj = this.toObject();\n    return {\n      type: \"symbol\",\n      printname: obj.printname,\n      symvalue: obj.symvalue,\n      internal: obj.internal\n    };\n  }\n  toObject() {\n    return {\n      printname: this.printname().isUnbound() ? null : this.printname().toString(),\n      symvalue: this.symvalue().isUnbound() ? null : this.symvalue().ptr,\n      internal: this.internal().isNull() ? null : this.internal().ptr\n    };\n  }\n  toString() {\n    return this.printname().toString();\n  }\n  printname() {\n    return RString.wrap(Module._PRINTNAME(this.ptr));\n  }\n  symvalue() {\n    return RObject.wrap(Module._SYMVALUE(this.ptr));\n  }\n  internal() {\n    return RObject.wrap(Module._INTERNAL(this.ptr));\n  }\n};\nvar RPairlist = class extends RObject {\n  constructor(val) {\n    if (val instanceof RObjectBase) {\n      assertRType(val, \"pairlist\");\n      super(val);\n      return this;\n    }\n    const prot = { n: 0 };\n    try {\n      const { names, values } = toWebRData(val);\n      const list = RPairlist.wrap(Module._Rf_allocList(values.length));\n      protectInc(list, prot);\n      for (let [i, next] = [0, list]; !next.isNull(); [i, next] = [i + 1, next.cdr()]) {\n        next.setcar(new RObject(values[i]));\n      }\n      list.setNames(names);\n      super(list);\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n  get length() {\n    return this.toArray().length;\n  }\n  toArray(options = { depth: 1 }) {\n    return this.toJs(options).values;\n  }\n  toObject({\n    allowDuplicateKey = true,\n    allowEmptyKey = false,\n    depth = 1\n  } = {}) {\n    const entries = this.entries({ depth });\n    const keys = entries.map(([k, v]) => k);\n    if (!allowDuplicateKey && new Set(keys).size !== keys.length) {\n      throw new Error(\"Duplicate key when converting pairlist without allowDuplicateKey enabled\");\n    }\n    if (!allowEmptyKey && keys.some((k) => !k)) {\n      throw new Error(\"Empty or null key when converting pairlist without allowEmptyKey enabled\");\n    }\n    return Object.fromEntries(\n      entries.filter((u, idx) => entries.findIndex((v) => v[0] === u[0]) === idx)\n    );\n  }\n  entries(options = { depth: 1 }) {\n    const obj = this.toJs(options);\n    return obj.values.map((v, i) => [obj.names ? obj.names[i] : null, v]);\n  }\n  toJs(options = { depth: 0 }, depth = 1) {\n    const namesArray = [];\n    let hasNames = false;\n    const values = [];\n    for (let next = this; !next.isNull(); next = next.cdr()) {\n      const symbol = next.tag();\n      if (symbol.isNull()) {\n        namesArray.push(\"\");\n      } else {\n        hasNames = true;\n        namesArray.push(symbol.toString());\n      }\n      if (options.depth && depth >= options.depth) {\n        values.push(next.car());\n      } else {\n        values.push(next.car().toJs(options, depth + 1));\n      }\n    }\n    const names = hasNames ? namesArray : null;\n    return { type: \"pairlist\", names, values };\n  }\n  includes(name) {\n    return name in this.toObject();\n  }\n  setcar(obj) {\n    Module._SETCAR(this.ptr, obj.ptr);\n  }\n  car() {\n    return RObject.wrap(Module._CAR(this.ptr));\n  }\n  cdr() {\n    return RObject.wrap(Module._CDR(this.ptr));\n  }\n  tag() {\n    return RObject.wrap(Module._TAG(this.ptr));\n  }\n};\nvar RCall = class extends RObject {\n  constructor(val) {\n    if (val instanceof RObjectBase) {\n      assertRType(val, \"call\");\n      super(val);\n      return this;\n    }\n    const prot = { n: 0 };\n    try {\n      const { values } = toWebRData(val);\n      const objs2 = values.map((value) => protectInc(new RObject(value), prot));\n      const call = RCall.wrap(Module._Rf_allocVector(RTypeMap.call, values.length));\n      protectInc(call, prot);\n      for (let [i, next] = [0, call]; !next.isNull(); [i, next] = [i + 1, next.cdr()]) {\n        next.setcar(objs2[i]);\n      }\n      super(call);\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n  setcar(obj) {\n    Module._SETCAR(this.ptr, obj.ptr);\n  }\n  car() {\n    return RObject.wrap(Module._CAR(this.ptr));\n  }\n  cdr() {\n    return RObject.wrap(Module._CDR(this.ptr));\n  }\n  eval() {\n    return RObject.wrap(safeEval(this.ptr, objs.baseEnv));\n  }\n};\nvar RList = class extends RObject {\n  constructor(val) {\n    if (val instanceof RObjectBase) {\n      assertRType(val, \"list\");\n      super(val);\n      return this;\n    }\n    const prot = { n: 0 };\n    try {\n      const { names, values } = toWebRData(val);\n      const ptr = Module._Rf_allocVector(RTypeMap.list, values.length);\n      protectInc(ptr, prot);\n      values.forEach((v, i) => {\n        Module._SET_VECTOR_ELT(ptr, i, new RObject(v).ptr);\n      });\n      RObject.wrap(ptr).setNames(names);\n      super(new RObjectBase(ptr));\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n  get length() {\n    return Module._LENGTH(this.ptr);\n  }\n  toArray(options = { depth: 1 }) {\n    return this.toJs(options).values;\n  }\n  toObject({\n    allowDuplicateKey = true,\n    allowEmptyKey = false,\n    depth = 1\n  } = {}) {\n    const entries = this.entries({ depth });\n    const keys = entries.map(([k, v]) => k);\n    if (!allowDuplicateKey && new Set(keys).size !== keys.length) {\n      throw new Error(\"Duplicate key when converting list without allowDuplicateKey enabled\");\n    }\n    if (!allowEmptyKey && keys.some((k) => !k)) {\n      throw new Error(\"Empty or null key when converting list without allowEmptyKey enabled\");\n    }\n    return Object.fromEntries(\n      entries.filter((u, idx) => entries.findIndex((v) => v[0] === u[0]) === idx)\n    );\n  }\n  entries(options = { depth: 1 }) {\n    const obj = this.toJs(options);\n    return obj.values.map((v, i) => [obj.names ? obj.names[i] : null, v]);\n  }\n  toJs(options = { depth: 0 }, depth = 1) {\n    return {\n      type: \"list\",\n      names: this.names(),\n      values: [...Array(this.length).keys()].map((i) => {\n        if (options.depth && depth >= options.depth) {\n          return this.get(i + 1);\n        } else {\n          return this.get(i + 1).toJs(options, depth + 1);\n        }\n      })\n    };\n  }\n};\nvar RFunction = class extends RObject {\n  exec(...args) {\n    const prot = { n: 0 };\n    try {\n      const call = new RCall([this, ...args]);\n      protectInc(call, prot);\n      return call.eval();\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n};\nvar RString = class extends RObject {\n  constructor(x) {\n    if (x instanceof RObjectBase) {\n      assertRType(x, \"string\");\n      super(x);\n      return;\n    }\n    const name = Module.allocateUTF8(x);\n    try {\n      super(new RObjectBase(Module._Rf_mkChar(name)));\n    } finally {\n      Module._free(name);\n    }\n  }\n  toString() {\n    return Module.UTF8ToString(Module._R_CHAR(this.ptr));\n  }\n  toJs() {\n    return {\n      type: \"string\",\n      value: this.toString()\n    };\n  }\n};\nvar REnvironment = class extends RObject {\n  constructor(val = {}) {\n    if (val instanceof RObjectBase) {\n      assertRType(val, \"environment\");\n      super(val);\n      return this;\n    }\n    let nProt = 0;\n    try {\n      const { names, values } = toWebRData(val);\n      const ptr = protect(Module._R_NewEnv(objs.globalEnv.ptr, 0, 0));\n      ++nProt;\n      values.forEach((v, i) => {\n        const name = names ? names[i] : null;\n        if (!name) {\n          throw new Error(\"Can't create object in new environment with empty symbol name\");\n        }\n        const sym = new RSymbol(name);\n        const vObj = protect(new RObject(v));\n        try {\n          envPoke(ptr, sym, vObj);\n        } finally {\n          unprotect(1);\n        }\n      });\n      super(new RObjectBase(ptr));\n    } finally {\n      unprotect(nProt);\n    }\n  }\n  ls(all = false, sorted = true) {\n    const ls = RCharacter.wrap(Module._R_lsInternal3(this.ptr, Number(all), Number(sorted)));\n    return ls.toArray();\n  }\n  bind(name, value) {\n    const sym = new RSymbol(name);\n    const valueObj = protect(new RObject(value));\n    try {\n      envPoke(this, sym, valueObj);\n    } finally {\n      unprotect(1);\n    }\n  }\n  names() {\n    return this.ls(true, true);\n  }\n  frame() {\n    return RObject.wrap(Module._FRAME(this.ptr));\n  }\n  subset(prop) {\n    if (typeof prop === \"number\") {\n      throw new Error(\"Object of type environment is not subsettable\");\n    }\n    return this.getDollar(prop);\n  }\n  toObject({ depth = 0 } = {}) {\n    const symbols = this.names();\n    return Object.fromEntries(\n      [...Array(symbols.length).keys()].map((i) => {\n        return [symbols[i], this.getDollar(symbols[i]).toJs({ depth })];\n      })\n    );\n  }\n  toJs(options = { depth: 0 }, depth = 1) {\n    const names = this.names();\n    const values = [...Array(names.length).keys()].map((i) => {\n      if (options.depth && depth >= options.depth) {\n        return this.getDollar(names[i]);\n      } else {\n        return this.getDollar(names[i]).toJs(options, depth + 1);\n      }\n    });\n    return {\n      type: \"environment\",\n      names,\n      values\n    };\n  }\n};\nvar RVectorAtomic = class extends RObject {\n  constructor(val, kind, newSetter) {\n    if (val instanceof RObjectBase) {\n      assertRType(val, kind);\n      super(val);\n      return this;\n    }\n    const prot = { n: 0 };\n    try {\n      const { names, values } = toWebRData(val);\n      const ptr = Module._Rf_allocVector(RTypeMap[kind], values.length);\n      protectInc(ptr, prot);\n      values.forEach(newSetter(ptr));\n      RObject.wrap(ptr).setNames(names);\n      super(new RObjectBase(ptr));\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n  get length() {\n    return Module._LENGTH(this.ptr);\n  }\n  get(prop) {\n    return super.get(prop);\n  }\n  subset(prop) {\n    return super.subset(prop);\n  }\n  getDollar(prop) {\n    throw new Error(\"$ operator is invalid for atomic vectors\");\n  }\n  detectMissing() {\n    const prot = { n: 0 };\n    try {\n      const call = Module._Rf_lang2(new RSymbol(\"is.na\").ptr, this.ptr);\n      protectInc(call, prot);\n      const val = RLogical.wrap(safeEval(call, objs.baseEnv));\n      protectInc(val, prot);\n      const ret = val.toTypedArray();\n      return Array.from(ret).map((elt) => Boolean(elt));\n    } finally {\n      unprotect(prot.n);\n    }\n  }\n  toArray() {\n    const arr = this.toTypedArray();\n    return this.detectMissing().map((m, idx) => m ? null : arr[idx]);\n  }\n  toObject({ allowDuplicateKey = true, allowEmptyKey = false } = {}) {\n    const entries = this.entries();\n    const keys = entries.map(([k, v]) => k);\n    if (!allowDuplicateKey && new Set(keys).size !== keys.length) {\n      throw new Error(\n        \"Duplicate key when converting atomic vector without allowDuplicateKey enabled\"\n      );\n    }\n    if (!allowEmptyKey && keys.some((k) => !k)) {\n      throw new Error(\n        \"Empty or null key when converting atomic vector without allowEmptyKey enabled\"\n      );\n    }\n    return Object.fromEntries(\n      entries.filter((u, idx) => entries.findIndex((v) => v[0] === u[0]) === idx)\n    );\n  }\n  entries() {\n    const values = this.toArray();\n    const names = this.names();\n    return values.map((v, i) => [names ? names[i] : null, v]);\n  }\n  toJs() {\n    return {\n      type: this.type(),\n      names: this.names(),\n      values: this.toArray()\n    };\n  }\n};\nvar _newSetter;\nvar _RLogical = class extends RVectorAtomic {\n  constructor(val) {\n    super(val, \"logical\", __privateGet(_RLogical, _newSetter));\n  }\n  getBoolean(idx) {\n    return this.get(idx).toArray()[0];\n  }\n  toBoolean() {\n    if (this.length !== 1) {\n      throw new Error(\"Can't convert atomic vector of length > 1 to a scalar JS value\");\n    }\n    const val = this.getBoolean(1);\n    if (val === null) {\n      throw new Error(\"Can't convert missing value `NA` to a JS boolean\");\n    }\n    return val;\n  }\n  toTypedArray() {\n    return new Int32Array(\n      Module.HEAP32.subarray(\n        Module._LOGICAL(this.ptr) / 4,\n        Module._LOGICAL(this.ptr) / 4 + this.length\n      )\n    );\n  }\n  toArray() {\n    const arr = this.toTypedArray();\n    return this.detectMissing().map((m, idx) => m ? null : Boolean(arr[idx]));\n  }\n};\nvar RLogical = _RLogical;\n_newSetter = new WeakMap();\n__privateAdd(RLogical, _newSetter, (ptr) => {\n  const data = Module._LOGICAL(ptr);\n  const naLogical = Module.getValue(Module._R_NaInt, \"i32\");\n  return (v, i) => {\n    Module.setValue(data + 4 * i, v === null ? naLogical : Boolean(v), \"i32\");\n  };\n});\nvar _newSetter2;\nvar _RInteger = class extends RVectorAtomic {\n  constructor(val) {\n    super(val, \"integer\", __privateGet(_RInteger, _newSetter2));\n  }\n  getNumber(idx) {\n    return this.get(idx).toArray()[0];\n  }\n  toNumber() {\n    if (this.length !== 1) {\n      throw new Error(\"Can't convert atomic vector of length > 1 to a scalar JS value\");\n    }\n    const val = this.getNumber(1);\n    if (val === null) {\n      throw new Error(\"Can't convert missing value `NA` to a JS number\");\n    }\n    return val;\n  }\n  toTypedArray() {\n    return new Int32Array(\n      Module.HEAP32.subarray(\n        Module._INTEGER(this.ptr) / 4,\n        Module._INTEGER(this.ptr) / 4 + this.length\n      )\n    );\n  }\n};\nvar RInteger = _RInteger;\n_newSetter2 = new WeakMap();\n__privateAdd(RInteger, _newSetter2, (ptr) => {\n  const data = Module._INTEGER(ptr);\n  const naInteger = Module.getValue(Module._R_NaInt, \"i32\");\n  return (v, i) => {\n    Module.setValue(data + 4 * i, v === null ? naInteger : Math.round(Number(v)), \"i32\");\n  };\n});\nvar _newSetter3;\nvar _RDouble = class extends RVectorAtomic {\n  constructor(val) {\n    super(val, \"double\", __privateGet(_RDouble, _newSetter3));\n  }\n  getNumber(idx) {\n    return this.get(idx).toArray()[0];\n  }\n  toNumber() {\n    if (this.length !== 1) {\n      throw new Error(\"Can't convert atomic vector of length > 1 to a scalar JS value\");\n    }\n    const val = this.getNumber(1);\n    if (val === null) {\n      throw new Error(\"Can't convert missing value `NA` to a JS number\");\n    }\n    return val;\n  }\n  toTypedArray() {\n    return new Float64Array(\n      Module.HEAPF64.subarray(Module._REAL(this.ptr) / 8, Module._REAL(this.ptr) / 8 + this.length)\n    );\n  }\n};\nvar RDouble = _RDouble;\n_newSetter3 = new WeakMap();\n__privateAdd(RDouble, _newSetter3, (ptr) => {\n  const data = Module._REAL(ptr);\n  const naDouble = Module.getValue(Module._R_NaReal, \"double\");\n  return (v, i) => {\n    Module.setValue(data + 8 * i, v === null ? naDouble : v, \"double\");\n  };\n});\nvar _newSetter4;\nvar _RComplex = class extends RVectorAtomic {\n  constructor(val) {\n    super(val, \"complex\", __privateGet(_RComplex, _newSetter4));\n  }\n  getComplex(idx) {\n    return this.get(idx).toArray()[0];\n  }\n  toComplex() {\n    if (this.length !== 1) {\n      throw new Error(\"Can't convert atomic vector of length > 1 to a scalar JS value\");\n    }\n    const val = this.getComplex(1);\n    if (val === null) {\n      throw new Error(\"Can't convert missing value `NA` to a JS object\");\n    }\n    return val;\n  }\n  toTypedArray() {\n    return new Float64Array(\n      Module.HEAPF64.subarray(\n        Module._COMPLEX(this.ptr) / 8,\n        Module._COMPLEX(this.ptr) / 8 + 2 * this.length\n      )\n    );\n  }\n  toArray() {\n    const arr = this.toTypedArray();\n    return this.detectMissing().map(\n      (m, idx) => m ? null : { re: arr[2 * idx], im: arr[2 * idx + 1] }\n    );\n  }\n};\nvar RComplex = _RComplex;\n_newSetter4 = new WeakMap();\n__privateAdd(RComplex, _newSetter4, (ptr) => {\n  const data = Module._COMPLEX(ptr);\n  const naDouble = Module.getValue(Module._R_NaReal, \"double\");\n  return (v, i) => {\n    Module.setValue(data + 8 * (2 * i), v === null ? naDouble : v.re, \"double\");\n    Module.setValue(data + 8 * (2 * i + 1), v === null ? naDouble : v.im, \"double\");\n  };\n});\nvar _newSetter5;\nvar _RCharacter = class extends RVectorAtomic {\n  constructor(val) {\n    super(val, \"character\", __privateGet(_RCharacter, _newSetter5));\n  }\n  getString(idx) {\n    return this.get(idx).toArray()[0];\n  }\n  toString() {\n    if (this.length !== 1) {\n      throw new Error(\"Can't convert atomic vector of length > 1 to a scalar JS value\");\n    }\n    const val = this.getString(1);\n    if (val === null) {\n      throw new Error(\"Can't convert missing value `NA` to a JS string\");\n    }\n    return val;\n  }\n  toTypedArray() {\n    return new Uint32Array(\n      Module.HEAPU32.subarray(\n        Module._STRING_PTR(this.ptr) / 4,\n        Module._STRING_PTR(this.ptr) / 4 + this.length\n      )\n    );\n  }\n  toArray() {\n    return this.detectMissing().map(\n      (m, idx) => m ? null : Module.UTF8ToString(Module._R_CHAR(Module._STRING_ELT(this.ptr, idx)))\n    );\n  }\n};\nvar RCharacter = _RCharacter;\n_newSetter5 = new WeakMap();\n__privateAdd(RCharacter, _newSetter5, (ptr) => {\n  return (v, i) => {\n    if (v === null) {\n      Module._SET_STRING_ELT(ptr, i, objs.naString.ptr);\n    } else {\n      Module._SET_STRING_ELT(ptr, i, new RString(v).ptr);\n    }\n  };\n});\nvar _newSetter6;\nvar _RRaw = class extends RVectorAtomic {\n  constructor(val) {\n    super(val, \"raw\", __privateGet(_RRaw, _newSetter6));\n  }\n  getNumber(idx) {\n    return this.get(idx).toArray()[0];\n  }\n  toNumber() {\n    if (this.length !== 1) {\n      throw new Error(\"Can't convert atomic vector of length > 1 to a scalar JS value\");\n    }\n    const val = this.getNumber(1);\n    if (val === null) {\n      throw new Error(\"Can't convert missing value `NA` to a JS number\");\n    }\n    return val;\n  }\n  toTypedArray() {\n    return new Uint8Array(\n      Module.HEAPU8.subarray(Module._RAW(this.ptr), Module._RAW(this.ptr) + this.length)\n    );\n  }\n};\nvar RRaw = _RRaw;\n_newSetter6 = new WeakMap();\n__privateAdd(RRaw, _newSetter6, (ptr) => {\n  const data = Module._RAW(ptr);\n  return (v, i) => {\n    Module.setValue(data + i, Number(v), \"i8\");\n  };\n});\nfunction toWebRData(jsObj) {\n  if (isWebRDataJs(jsObj)) {\n    return jsObj;\n  } else if (Array.isArray(jsObj)) {\n    return { names: null, values: jsObj };\n  } else if (jsObj && typeof jsObj === \"object\" && !isComplex(jsObj)) {\n    return {\n      names: Object.keys(jsObj),\n      values: Object.values(jsObj)\n    };\n  }\n  return { names: null, values: [jsObj] };\n}\nfunction getRWorkerClass(type) {\n  const typeClasses = {\n    [RTypeMap.null]: RNull,\n    [RTypeMap.symbol]: RSymbol,\n    [RTypeMap.pairlist]: RPairlist,\n    [RTypeMap.closure]: RFunction,\n    [RTypeMap.environment]: REnvironment,\n    [RTypeMap.call]: RCall,\n    [RTypeMap.special]: RFunction,\n    [RTypeMap.builtin]: RFunction,\n    [RTypeMap.string]: RString,\n    [RTypeMap.logical]: RLogical,\n    [RTypeMap.integer]: RInteger,\n    [RTypeMap.double]: RDouble,\n    [RTypeMap.complex]: RComplex,\n    [RTypeMap.character]: RCharacter,\n    [RTypeMap.list]: RList,\n    [RTypeMap.raw]: RRaw,\n    [RTypeMap.function]: RFunction\n  };\n  if (type in typeClasses) {\n    return typeClasses[type];\n  }\n  return RObject;\n}\nfunction isRObject2(value) {\n  return value instanceof RObject;\n}\nvar objs;\n\n// webR/proxy.ts\nfunction empty() {\n}\nfunction targetAsyncIterator(chan, proxy) {\n  return async function* () {\n    const msg = {\n      type: \"callRObjectMethod\",\n      data: {\n        payload: proxy._payload,\n        prop: \"getPropertyValue\",\n        args: [{ payloadType: \"raw\", obj: \"length\" }],\n        shelter: void 0\n      }\n    };\n    const reply = await chan.request(msg);\n    if (typeof reply.obj !== \"number\") {\n      throw new Error(\"Cannot iterate over object, unexpected type for length property.\");\n    }\n    for (let i = 1; i <= reply.obj; i++) {\n      yield proxy.get(i);\n    }\n  };\n}\nfunction targetMethod(chan, prop, payload) {\n  return async (..._args) => {\n    const args = _args.map((arg) => {\n      if (isRObject(arg)) {\n        return arg._payload;\n      }\n      return {\n        obj: replaceInObject(arg, isRObject, (obj) => obj._payload),\n        payloadType: \"raw\"\n      };\n    });\n    const msg = {\n      type: \"callRObjectMethod\",\n      data: { payload, prop, args }\n    };\n    const reply = await chan.request(msg);\n    switch (reply.payloadType) {\n      case \"ptr\":\n        return newRProxy(chan, reply);\n      case \"raw\": {\n        const proxyReply = replaceInObject(\n          reply,\n          isWebRPayloadPtr,\n          (obj, chan2) => newRProxy(chan2, obj),\n          chan\n        );\n        return proxyReply.obj;\n      }\n    }\n  };\n}\nasync function newRObject(chan, objType, shelter, value) {\n  const msg = {\n    type: \"newRObject\",\n    data: {\n      objType,\n      obj: replaceInObject(value, isRObject, (obj) => obj._payload),\n      shelter\n    }\n  };\n  const payload = await chan.request(msg);\n  switch (payload.payloadType) {\n    case \"raw\":\n      throw new Error(\"Unexpected raw payload type returned from newRObject\");\n    case \"ptr\":\n      return newRProxy(chan, payload);\n  }\n}\nfunction newRProxy(chan, payload) {\n  var _a;\n  const proxy = new Proxy(\n    ((_a = payload.obj.methods) == null ? void 0 : _a.includes(\"exec\")) ? Object.assign(empty, { ...payload }) : payload,\n    {\n      get: (_, prop) => {\n        var _a2;\n        if (prop === \"_payload\") {\n          return payload;\n        } else if (prop === Symbol.asyncIterator) {\n          return targetAsyncIterator(chan, proxy);\n        } else if ((_a2 = payload.obj.methods) == null ? void 0 : _a2.includes(prop.toString())) {\n          return targetMethod(chan, prop.toString(), payload);\n        }\n      },\n      apply: async (_, _thisArg, args) => {\n        const res = await newRProxy(chan, payload).exec(...args);\n        return isRFunction(res) ? res : res.toJs();\n      }\n    }\n  );\n  return proxy;\n}\nfunction newRClassProxy(chan, shelter, objType) {\n  return new Proxy(RObject, {\n    construct: (_, args) => newRObject(chan, objType, shelter, ...args),\n    get: (_, prop) => {\n      return targetMethod(chan, prop.toString());\n    }\n  });\n}\n\n// console/console.ts\nvar _stdout, _stderr, _prompt, _canvasExec, _defaultStdout, _defaultStderr, _defaultPrompt, _defaultCanvasExec, _run, run_fn;\nvar Console = class {\n  constructor(callbacks = {}, options = {\n    REnv: {\n      R_HOME: \"/usr/lib/R\",\n      R_ENABLE_JIT: \"0\",\n      R_DEFAULT_DEVICE: \"canvas\"\n    }\n  }) {\n    __privateAdd(this, _run);\n    __privateAdd(this, _stdout, void 0);\n    __privateAdd(this, _stderr, void 0);\n    __privateAdd(this, _prompt, void 0);\n    __privateAdd(this, _canvasExec, void 0);\n    __privateAdd(this, _defaultStdout, (text) => {\n      console.log(text);\n    });\n    __privateAdd(this, _defaultStderr, (text) => {\n      console.error(text);\n    });\n    __privateAdd(this, _defaultPrompt, (text) => {\n      const input = prompt(text);\n      if (input)\n        this.stdin(`${input}\n`);\n    });\n    __privateAdd(this, _defaultCanvasExec, (exec) => {\n      if (IN_NODE) {\n        throw new Error(\"Plotting with HTML canvas is not yet supported under Node\");\n      }\n      Function(`this.getContext('2d').${exec}`).bind(this.canvas)();\n    });\n    this.webR = new WebR(options);\n    if (!IN_NODE) {\n      this.canvas = document.createElement(\"canvas\");\n      this.canvas.setAttribute(\"width\", \"1008\");\n      this.canvas.setAttribute(\"height\", \"1008\");\n    }\n    __privateSet(this, _stdout, callbacks.stdout || __privateGet(this, _defaultStdout));\n    __privateSet(this, _stderr, callbacks.stderr || __privateGet(this, _defaultStderr));\n    __privateSet(this, _prompt, callbacks.prompt || __privateGet(this, _defaultPrompt));\n    __privateSet(this, _canvasExec, callbacks.canvasExec || __privateGet(this, _defaultCanvasExec));\n  }\n  stdin(input) {\n    this.webR.writeConsole(input);\n  }\n  interrupt() {\n    this.webR.interrupt();\n  }\n  run() {\n    __privateMethod(this, _run, run_fn).call(this);\n  }\n};\n_stdout = new WeakMap();\n_stderr = new WeakMap();\n_prompt = new WeakMap();\n_canvasExec = new WeakMap();\n_defaultStdout = new WeakMap();\n_defaultStderr = new WeakMap();\n_defaultPrompt = new WeakMap();\n_defaultCanvasExec = new WeakMap();\n_run = new WeakSet();\nrun_fn = async function() {\n  for (; ; ) {\n    const output = await this.webR.read();\n    switch (output.type) {\n      case \"stdout\":\n        __privateGet(this, _stdout).call(this, output.data);\n        break;\n      case \"stderr\":\n        __privateGet(this, _stderr).call(this, output.data);\n        break;\n      case \"prompt\":\n        __privateGet(this, _prompt).call(this, output.data);\n        break;\n      case \"canvasExec\":\n        __privateGet(this, _canvasExec).call(this, output.data);\n        break;\n      default:\n        console.warn(`Unhandled output type for webR Console: ${output.type}.`);\n    }\n  }\n};\n\n// webR/webr-main.ts\nvar defaultEnv = {\n  R_HOME: \"/usr/lib/R\",\n  R_ENABLE_JIT: \"0\"\n};\nvar defaultOptions = {\n  RArgs: [],\n  REnv: defaultEnv,\n  WEBR_URL: BASE_URL,\n  SW_URL: \"\",\n  PKG_URL: PKG_BASE_URL,\n  homedir: \"/home/web_user\",\n  interactive: true,\n  channelType: ChannelType.Automatic\n};\nvar _chan;\nvar WebR = class {\n  constructor(options = {}) {\n    __privateAdd(this, _chan, void 0);\n    this.FS = {\n      lookupPath: async (path) => {\n        const msg = { type: \"lookupPath\", data: { path } };\n        const payload = await __privateGet(this, _chan).request(msg);\n        return payload.obj;\n      },\n      mkdir: async (path) => {\n        const msg = { type: \"mkdir\", data: { path } };\n        const payload = await __privateGet(this, _chan).request(msg);\n        return payload.obj;\n      },\n      readFile: async (path, flags) => {\n        const msg = { type: \"readFile\", data: { path, flags } };\n        const payload = await __privateGet(this, _chan).request(msg);\n        return payload.obj;\n      },\n      rmdir: async (path) => {\n        const msg = { type: \"rmdir\", data: { path } };\n        await __privateGet(this, _chan).request(msg);\n      },\n      writeFile: async (path, data, flags) => {\n        const msg = { type: \"writeFile\", data: { path, data, flags } };\n        await __privateGet(this, _chan).request(msg);\n      },\n      unlink: async (path) => {\n        const msg = { type: \"unlink\", data: { path } };\n        await __privateGet(this, _chan).request(msg);\n      }\n    };\n    const config = Object.assign(defaultOptions, options);\n    __privateSet(this, _chan, newChannelMain(config));\n    this.objs = {};\n    this.Shelter = newShelterProxy(__privateGet(this, _chan));\n  }\n  async init() {\n    const init = await __privateGet(this, _chan).initialised;\n    this.globalShelter = await new this.Shelter();\n    this.RObject = this.globalShelter.RObject;\n    this.RLogical = this.globalShelter.RLogical;\n    this.RInteger = this.globalShelter.RInteger;\n    this.RDouble = this.globalShelter.RDouble;\n    this.RComplex = this.globalShelter.RComplex;\n    this.RCharacter = this.globalShelter.RCharacter;\n    this.RRaw = this.globalShelter.RRaw;\n    this.RList = this.globalShelter.RList;\n    this.RPairlist = this.globalShelter.RPairlist;\n    this.REnvironment = this.globalShelter.REnvironment;\n    this.RSymbol = this.globalShelter.RSymbol;\n    this.RString = this.globalShelter.RString;\n    this.RCall = this.globalShelter.RCall;\n    this.objs = {\n      baseEnv: await this.RObject.getPersistentObject(\"baseEnv\"),\n      globalEnv: await this.RObject.getPersistentObject(\"globalEnv\"),\n      null: await this.RObject.getPersistentObject(\"null\"),\n      true: await this.RObject.getPersistentObject(\"true\"),\n      false: await this.RObject.getPersistentObject(\"false\"),\n      na: await this.RObject.getPersistentObject(\"na\")\n    };\n    return init;\n  }\n  close() {\n    __privateGet(this, _chan).close();\n  }\n  async read() {\n    return await __privateGet(this, _chan).read();\n  }\n  async flush() {\n    return await __privateGet(this, _chan).flush();\n  }\n  write(msg) {\n    __privateGet(this, _chan).write(msg);\n  }\n  writeConsole(input) {\n    this.write({ type: \"stdin\", data: input + \"\\n\" });\n  }\n  interrupt() {\n    __privateGet(this, _chan).interrupt();\n  }\n  async installPackages(packages) {\n    for (const pkg of packages) {\n      const msg = { type: \"installPackage\", data: { name: pkg } };\n      await __privateGet(this, _chan).request(msg);\n    }\n  }\n  async destroy(x) {\n    await this.globalShelter.destroy(x);\n  }\n  async evalR(code, options) {\n    return this.globalShelter.evalR(code, options);\n  }\n  async evalRVoid(code, options) {\n    return this.evalRRaw(code, \"void\", options);\n  }\n  async evalRBoolean(code, options) {\n    return this.evalRRaw(code, \"boolean\", options);\n  }\n  async evalRNumber(code, options) {\n    return this.evalRRaw(code, \"number\", options);\n  }\n  async evalRString(code, options) {\n    return this.evalRRaw(code, \"string\", options);\n  }\n  async evalRRaw(code, outputType, options = {}) {\n    const opts = replaceInObject(options, isRObject, (obj) => obj._payload);\n    const msg = {\n      type: \"evalRRaw\",\n      data: { code, options: opts, outputType }\n    };\n    const payload = await __privateGet(this, _chan).request(msg);\n    switch (payload.payloadType) {\n      case \"raw\":\n        return payload.obj;\n      case \"ptr\":\n        throw new Error(\"Unexpected ptr payload type returned from evalRVoid\");\n    }\n  }\n};\n_chan = new WeakMap();\nvar _id, _chan2, _initialised;\nvar Shelter = class {\n  constructor(chan) {\n    __privateAdd(this, _id, \"\");\n    __privateAdd(this, _chan2, void 0);\n    __privateAdd(this, _initialised, false);\n    __privateSet(this, _chan2, chan);\n  }\n  async init() {\n    if (__privateGet(this, _initialised)) {\n      return;\n    }\n    const msg = { type: \"newShelter\" };\n    const payload = await __privateGet(this, _chan2).request(msg);\n    __privateSet(this, _id, payload.obj);\n    this.RObject = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"object\");\n    this.RLogical = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"logical\");\n    this.RInteger = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"integer\");\n    this.RDouble = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"double\");\n    this.RComplex = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"complex\");\n    this.RCharacter = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"character\");\n    this.RRaw = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"raw\");\n    this.RList = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"list\");\n    this.RPairlist = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"pairlist\");\n    this.REnvironment = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"environment\");\n    this.RSymbol = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"symbol\");\n    this.RString = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"string\");\n    this.RCall = newRClassProxy(__privateGet(this, _chan2), __privateGet(this, _id), \"call\");\n    __privateSet(this, _initialised, true);\n  }\n  async purge() {\n    const msg = {\n      type: \"shelterPurge\",\n      data: __privateGet(this, _id)\n    };\n    await __privateGet(this, _chan2).request(msg);\n  }\n  async destroy(x) {\n    const msg = {\n      type: \"shelterDestroy\",\n      data: { id: __privateGet(this, _id), obj: x._payload }\n    };\n    await __privateGet(this, _chan2).request(msg);\n  }\n  async size() {\n    const msg = {\n      type: \"shelterSize\",\n      data: __privateGet(this, _id)\n    };\n    const payload = await __privateGet(this, _chan2).request(msg);\n    return payload.obj;\n  }\n  async evalR(code, options = {}) {\n    const opts = replaceInObject(options, isRObject, (obj) => obj._payload);\n    const msg = {\n      type: \"evalR\",\n      data: { code, options: opts, shelter: __privateGet(this, _id) }\n    };\n    const payload = await __privateGet(this, _chan2).request(msg);\n    switch (payload.payloadType) {\n      case \"raw\":\n        throw new Error(\"Unexpected payload type returned from evalR\");\n      default:\n        return newRProxy(__privateGet(this, _chan2), payload);\n    }\n  }\n  async captureR(code, options = {}) {\n    const opts = replaceInObject(options, isRObject, (obj) => obj._payload);\n    const msg = {\n      type: \"captureR\",\n      data: {\n        code,\n        options: opts,\n        shelter: __privateGet(this, _id)\n      }\n    };\n    const payload = await __privateGet(this, _chan2).request(msg);\n    switch (payload.payloadType) {\n      case \"ptr\":\n        throw new Error(\"Unexpected payload type returned from evalR\");\n      case \"raw\": {\n        const data = payload.obj;\n        const result = newRProxy(__privateGet(this, _chan2), data.result);\n        const output = data.output;\n        for (let i = 0; i < output.length; ++i) {\n          if (output[i].type !== \"stdout\" && output[i].type !== \"stderr\") {\n            output[i].data = newRProxy(__privateGet(this, _chan2), output[i].data);\n          }\n        }\n        return { result, output };\n      }\n    }\n  }\n};\n_id = new WeakMap();\n_chan2 = new WeakMap();\n_initialised = new WeakMap();\nfunction newShelterProxy(chan) {\n  return new Proxy(Shelter, {\n    construct: async () => {\n      const out = new Shelter(chan);\n      await out.init();\n      return out;\n    }\n  });\n}\nexport {\n  Console,\n  Shelter,\n  WebR\n};\n//# sourceMappingURL=webr.mjs.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"names":[],"sourceRoot":""}